import { Component, OnInit } from '@angular/core';
import { FormGroup, FormBuilder, FormArray, Validators, FormControl } from '@angular/forms';
import { MeterReadService, DeviceService } from '../../auth/services';
import { AuthbaseService } from '../../auth/authbase.service'
import { Router } from '@angular/router';
import { ToastrService } from 'ngx-toastr';
import { Observable } from 'rxjs';
import { map, startWith } from 'rxjs/operators';
import * as moment from 'moment';
@Component({
  selector: 'app-addread',
  templateUrl: './addread.component.html',
  styleUrls: ['./addread.component.scss']
})
export class AddreadComponent implements OnInit {
  maxDate = new Date();
  readForm: FormGroup;
  public stepHour = 1;
  public stepMinute = 1;
  public stepSecond = 1;
  data: any;
  timezonedata: any = [];
  hidestarttime: boolean = true;
  readtype = ['History', 'Delta', 'Aggregate'];
  unit = ['Wh', 'kWh', 'MWh', 'GWh'];
  options: string[] = ['One', 'Two', 'Three'];
  filteredOptions: Observable<string[]>;
  constructor(private fb: FormBuilder, private readService: MeterReadService,
    private deviceservice: DeviceService,
    private authService: AuthbaseService,
    private router: Router, private toastrService: ToastrService) { }
  ngOnInit() {
    this.readForm = this.fb.group({
      timezone: new FormControl(''),
      externalId: [null, Validators.required],
      type: [null, Validators.required],
      unit: [null, Validators.required],

      reads: this.fb.array([
      ])
    })
    const read = this.fb.group({
      starttimestamp: [''],
      endtimestamp: [null, Validators.required],
      value: [null, Validators.required],
    }, {
      validators: (control) => {
        console.log(control);
        if (control.value.starttimestamp > control.value.endtimestamp) {
          console.log('49');
          //@ts-ignore
          control.get("endtimestamp").setErrors({ notSame: true });
        }
        return null;
      },
    })
    this.addreads.push(read);
    this.DisplayList();
    this.TimeZoneList();
    this.readForm.controls['timezone'];
    this.filteredOptions = this.readForm.controls['timezone'].valueChanges.pipe(
      startWith(''),
      map(value => this._filter(value || '')),
    );
  }
  get addreads() {
    return this.readForm.controls["reads"] as FormArray;
  }
  DisplayList() {
    this.deviceservice.GetMyDevices().subscribe(
      (data) => {
        // display list in the console 
        console.log(data);
        this.data = data;
      }
    )
  }
  TimeZoneList() {
    this.authService.GetMethod('meter-reads/time-zones').subscribe(
      (data) => {
        // display list in the console 
        console.log(data);
        this.timezonedata = data;
      }
    )
  }
  onChangeEvent(event: any) {
    console.log(event);
    if (event === 'Delta' || event === 'Aggregate') {
      this.hidestarttime = false;
    } else {
      this.hidestarttime = true;
    }
  }
  private _filter(value: string): string[] {
    const filterValue = value.toLowerCase();

    return this.timezonedata.filter((option: string) => option.toLowerCase().includes(filterValue));
  }
  getErrorcheckconfirmPassword() {
    return this.readForm.controls["reads"].get('endtimestamp')?.hasError('required') ? 'This field is required (Password must contain minimum 6 characters (upper and/or lower case) and at least one number)' :
      this.readForm.controls["reads"].get('endtimestamp')?.hasError('notSame') ? ' Please add a valid endtimestamp' : '';
  }
  checkValidation(input: string) {
    const validation = this.readForm.controls["reads"].get(input)?.invalid && (this.readForm.controls["reads"].get(input)?.dirty || this.readForm.controls["reads"].get(input)?.touched)
    return validation;
  }
  onSubmit(): void {
    let externalId = this.readForm.value.externalId;   
    const myobj: any = {}
    if (this.readForm.value.timezone != null && this.readForm.value.type === 'History') {
      myobj['timezone'] = this.readForm.value.timezone
      myobj['type'] = this.readForm.value.type
      myobj['unit'] = this.readForm.value.unit
      let reads:any = []
      this.readForm.value.reads.forEach((ele: any) => {
        reads.push({
          starttimestamp: moment(ele.starttimestamp).format('YYYY-MM-DD HH:mm:ss'),
          endtimestamp: moment(ele.endtimestamp).format('YYYY-MM-DD HH:mm:ss'),
          value: ele.value,
        })
      })
      myobj['reads'] = reads
    } else if(this.readForm.value.timezone != null && this.readForm.value.type!= 'History'){
      myobj['type'] = this.readForm.value.type
      myobj['unit'] = this.readForm.value.unit
      let newreads:any = []
      this.readForm.value.reads.forEach((ele: any) => {
        newreads.push({
          starttimestamp: "",
          endtimestamp: moment(ele.endtimestamp).format('YYYY-MM-DD HH:mm:ss'),
          value: ele.value,
        })
      })
      myobj['reads'] = newreads
    } else {
      myobj['type'] = this.readForm.value.type
      myobj['unit'] = this.readForm.value.unit
      let newreads:any = []
      this.readForm.value.reads.forEach((ele: any) => {
        newreads.push({
          starttimestamp: ele.starttimestamp,
          endtimestamp: ele.endtimestamp,
          value: ele.value,
        })
      })
      myobj['reads'] = newreads
    }  
    this.readService.PostRead(externalId,myobj).subscribe({
      next: (data: any) => {
        console.log(data)
        this.readForm.reset();
        this.toastrService.success('Successfully!', 'Read Add SuccessFully!!');
      },
      error: (err: { error: { message: string | undefined; }; }) => {                          //Error callback
        console.error('error caught in component', err)
        this.toastrService.error('error!', err.error.message);
      }
    });
  }

}
